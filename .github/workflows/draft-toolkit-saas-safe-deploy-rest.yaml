name: APIC Deploy via Toolkit (SaaS-safe)

on:
  workflow_dispatch:
    inputs:
      api_file:
        description: "Path to API YAML"
        default: "apis/hello-proxy.yaml"
        required: true
      product_file:
        description: "Path to Product YAML"
        default: "products/hello-product.yaml"
        required: true
      realm:
        description: "Login realm"
        default: "provider/default-idp-2"
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      # Manager base URL, org, and catalog (e.g., sandbox)
      APIC_BASE:     ${{ secrets.APIC_BASE }}
      APIC_USERNAME: ${{ secrets.APIC_USERNAME }}
      APIC_PASSWORD: ${{ secrets.APIC_PASSWORD }}
      APIC_ORG:      ${{ secrets.APIC_ORG }}
      APIC_CATALOG:  ${{ secrets.APIC_CATALOG }}

      # Optional ways to obtain the toolkit:
      # 1) Direct tarball URL (recommended for SaaS): store in secret APIC_TOOLKIT_URL
      APIC_TOOLKIT_URL: ${{ secrets.APIC_TOOLKIT_URL }}
      # 2) IBM Entitled Registry (containerized toolkit) if you have access:
      IBM_ENTITLEMENT_KEY: ${{ secrets.IBM_ENTITLEMENT_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          for v in APIC_BASE APIC_USERNAME APIC_PASSWORD APIC_ORG APIC_CATALOG ; do
            [[ -n "${!v:-}" ]] || { echo "::error::$v is empty"; exit 1; }
          done
          echo "Core secrets present."

      - name: Prepare APIC Toolkit (tarball or container)
        id: prep
        run: |
          set -euo pipefail
          APIC_HOME="${RUNNER_TEMP}/apic_home"
          mkdir -p "$APIC_HOME"

          if [[ -n "${APIC_TOOLKIT_URL:-}" ]]; then
            echo " Downloading Toolkit tarball from APIC_TOOLKIT_URL…"
            curl -fsSL "$APIC_TOOLKIT_URL" -o /tmp/apic.tgz
            sudo mkdir -p /usr/local/apic
            sudo tar -C /usr/local/apic -xzf /tmp/apic.tgz
            # Common layouts include /usr/local/apic/bin/apic
            if [[ ! -x /usr/local/apic/bin/apic ]]; then
              echo "::error::Couldn't find apic binary in the tarball (expected /usr/local/apic/bin/apic)."
              exit 1
            fi
            sudo ln -sf /usr/local/apic/bin/apic /usr/local/bin/apic
            apic --version
            echo "mode=host" >> "$GITHUB_OUTPUT"
            echo "apic_cmd=apic" >> "$GITHUB_OUTPUT"
            echo "APIC_HOME=$APIC_HOME" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ -n "${IBM_ENTITLEMENT_KEY:-}" ]]; then
            echo "Logging into IBM Entitled Registry (cp.icr.io)…"
            echo "$IBM_ENTITLEMENT_KEY" | docker login cp.icr.io -u cp --password-stdin

            TOOLKIT_IMAGE="cp.icr.io/cp/apic/toolkit:10.0.8.0"
            echo "Pulling $TOOLKIT_IMAGE…"
            docker pull "$TOOLKIT_IMAGE"

            # Build a wrapper to run 'apic' inside the container with persisted HOME
            APIC_CMD="docker run --rm \
              -v \"$PWD\":/work -w /work \
              -v \"$APIC_HOME\":/root \
              $TOOLKIT_IMAGE apic"
            # Sanity check
            bash -lc "$APIC_CMD --version"

            echo "mode=container" >> "$GITHUB_OUTPUT"
            echo "apic_cmd=$APIC_CMD" >> "$GITHUB_OUTPUT"
            echo "APIC_HOME=$APIC_HOME" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "::error::No Toolkit source provided. Set either APIC_TOOLKIT_URL (preferred) or IBM_ENTITLEMENT_KEY."
          exit 1

      - name: Login to APIC (CLI)
        run: |
          set -euo pipefail
          APIC_CMD='${{ steps.prep.outputs.apic_cmd }}'
          REALM='${{ github.event.inputs.realm }}'
          # Persist CLI state so subsequent steps reuse the session
          export HOME='${{ steps.prep.outputs.APIC_HOME }}'
          bash -lc "$APIC_CMD login \
            --server '${APIC_BASE}' \
            --username '${APIC_USERNAME}' \
            --password '${APIC_PASSWORD}' \
            --realm '$REALM' \
            --accept-license"

      - name: Push Draft API (create or update)
        run: |
          set -euo pipefail
          APIC_CMD='${{ steps.prep.outputs.apic_cmd }}'
          export HOME='${{ steps.prep.outputs.APIC_HOME }}'
          API_FILE='${{ github.event.inputs.api_file }}'
          # Try create then update (idempotent)
          bash -lc "$APIC_CMD drafts:apis:create '$API_FILE' --server '${APIC_BASE}' --org '${APIC_ORG}' --accept-license" || \
          bash -lc "$APIC_CMD drafts:apis:update '$API_FILE' --server '${APIC_BASE}' --org '${APIC_ORG}' --accept-license"

      - name: Push Draft Product (create or update)
        run: |
          set -euo pipefail
          APIC_CMD='${{ steps.prep.outputs.apic_cmd }}'
          export HOME='${{ steps.prep.outputs.APIC_HOME }}'
          PROD_FILE='${{ github.event.inputs.product_file }}'
          bash -lc "$APIC_CMD drafts:products:create '$PROD_FILE' --server '${APIC_BASE}' --org '${APIC_ORG}' --accept-license" || \
          bash -lc "$APIC_CMD drafts:products:update '$PROD_FILE' --server '${APIC_BASE}' --org '${APIC_ORG}' --accept-license"

      - name: Publish Product to catalog (stage)
        run: |
          set -euo pipefail
          APIC_CMD='${{ steps.prep.outputs.apic_cmd }}'
          export HOME='${{ steps.prep.outputs.APIC_HOME }}'
          PROD_FILE='${{ github.event.inputs.product_file }}'
          bash -lc "$APIC_CMD products:publish '$PROD_FILE' \
            --server '${APIC_BASE}' \
            --org '${APIC_ORG}' \
            --catalog '${APIC_CATALOG}' \
            --stage \
            --accept-license"
